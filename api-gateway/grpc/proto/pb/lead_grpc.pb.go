// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: lead.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LeadService_CreateLead_FullMethodName         = "/lead.LeadService/CreateLead"
	LeadService_GetLeadCommon_FullMethodName      = "/lead.LeadService/GetLeadCommon"
	LeadService_UpdateLead_FullMethodName         = "/lead.LeadService/UpdateLead"
	LeadService_DeleteLead_FullMethodName         = "/lead.LeadService/DeleteLead"
	LeadService_GetListSection_FullMethodName     = "/lead.LeadService/GetListSection"
	LeadService_GetLeadReports_FullMethodName     = "/lead.LeadService/GetLeadReports"
	LeadService_GetActiveLeadCount_FullMethodName = "/lead.LeadService/GetActiveLeadCount"
)

// LeadServiceClient is the client API for LeadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// lead_service_start
type LeadServiceClient interface {
	CreateLead(ctx context.Context, in *CreateLeadRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	GetLeadCommon(ctx context.Context, in *GetLeadCommonRequest, opts ...grpc.CallOption) (*GetLeadCommonResponse, error)
	UpdateLead(ctx context.Context, in *UpdateLeadRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	DeleteLead(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	GetListSection(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLeadListResponse, error)
	GetLeadReports(ctx context.Context, in *GetLeadReportsRequest, opts ...grpc.CallOption) (*GetLeadReportsResponse, error)
	GetActiveLeadCount(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetActiveLeadCountResponse, error)
}

type leadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLeadServiceClient(cc grpc.ClientConnInterface) LeadServiceClient {
	return &leadServiceClient{cc}
}

func (c *leadServiceClient) CreateLead(ctx context.Context, in *CreateLeadRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadService_CreateLead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetLeadCommon(ctx context.Context, in *GetLeadCommonRequest, opts ...grpc.CallOption) (*GetLeadCommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeadCommonResponse)
	err := c.cc.Invoke(ctx, LeadService_GetLeadCommon_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) UpdateLead(ctx context.Context, in *UpdateLeadRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadService_UpdateLead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) DeleteLead(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadService_DeleteLead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetListSection(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLeadListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeadListResponse)
	err := c.cc.Invoke(ctx, LeadService_GetListSection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetLeadReports(ctx context.Context, in *GetLeadReportsRequest, opts ...grpc.CallOption) (*GetLeadReportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeadReportsResponse)
	err := c.cc.Invoke(ctx, LeadService_GetLeadReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetActiveLeadCount(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetActiveLeadCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveLeadCountResponse)
	err := c.cc.Invoke(ctx, LeadService_GetActiveLeadCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeadServiceServer is the server API for LeadService service.
// All implementations must embed UnimplementedLeadServiceServer
// for forward compatibility.
//
// lead_service_start
type LeadServiceServer interface {
	CreateLead(context.Context, *CreateLeadRequest) (*AbsResponse, error)
	GetLeadCommon(context.Context, *GetLeadCommonRequest) (*GetLeadCommonResponse, error)
	UpdateLead(context.Context, *UpdateLeadRequest) (*AbsResponse, error)
	DeleteLead(context.Context, *DeleteAbsRequest) (*AbsResponse, error)
	GetListSection(context.Context, *emptypb.Empty) (*GetLeadListResponse, error)
	GetLeadReports(context.Context, *GetLeadReportsRequest) (*GetLeadReportsResponse, error)
	GetActiveLeadCount(context.Context, *emptypb.Empty) (*GetActiveLeadCountResponse, error)
	mustEmbedUnimplementedLeadServiceServer()
}

// UnimplementedLeadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLeadServiceServer struct{}

func (UnimplementedLeadServiceServer) CreateLead(context.Context, *CreateLeadRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLead not implemented")
}
func (UnimplementedLeadServiceServer) GetLeadCommon(context.Context, *GetLeadCommonRequest) (*GetLeadCommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeadCommon not implemented")
}
func (UnimplementedLeadServiceServer) UpdateLead(context.Context, *UpdateLeadRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLead not implemented")
}
func (UnimplementedLeadServiceServer) DeleteLead(context.Context, *DeleteAbsRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLead not implemented")
}
func (UnimplementedLeadServiceServer) GetListSection(context.Context, *emptypb.Empty) (*GetLeadListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListSection not implemented")
}
func (UnimplementedLeadServiceServer) GetLeadReports(context.Context, *GetLeadReportsRequest) (*GetLeadReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeadReports not implemented")
}
func (UnimplementedLeadServiceServer) GetActiveLeadCount(context.Context, *emptypb.Empty) (*GetActiveLeadCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveLeadCount not implemented")
}
func (UnimplementedLeadServiceServer) mustEmbedUnimplementedLeadServiceServer() {}
func (UnimplementedLeadServiceServer) testEmbeddedByValue()                     {}

// UnsafeLeadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeadServiceServer will
// result in compilation errors.
type UnsafeLeadServiceServer interface {
	mustEmbedUnimplementedLeadServiceServer()
}

func RegisterLeadServiceServer(s grpc.ServiceRegistrar, srv LeadServiceServer) {
	// If the following call pancis, it indicates UnimplementedLeadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LeadService_ServiceDesc, srv)
}

func _LeadService_CreateLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).CreateLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_CreateLead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).CreateLead(ctx, req.(*CreateLeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetLeadCommon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeadCommonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetLeadCommon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetLeadCommon_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetLeadCommon(ctx, req.(*GetLeadCommonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_UpdateLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).UpdateLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_UpdateLead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).UpdateLead(ctx, req.(*UpdateLeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_DeleteLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAbsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).DeleteLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_DeleteLead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).DeleteLead(ctx, req.(*DeleteAbsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetListSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetListSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetListSection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetListSection(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetLeadReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeadReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetLeadReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetLeadReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetLeadReports(ctx, req.(*GetLeadReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetActiveLeadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetActiveLeadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetActiveLeadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetActiveLeadCount(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// LeadService_ServiceDesc is the grpc.ServiceDesc for LeadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lead.LeadService",
	HandlerType: (*LeadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLead",
			Handler:    _LeadService_CreateLead_Handler,
		},
		{
			MethodName: "GetLeadCommon",
			Handler:    _LeadService_GetLeadCommon_Handler,
		},
		{
			MethodName: "UpdateLead",
			Handler:    _LeadService_UpdateLead_Handler,
		},
		{
			MethodName: "DeleteLead",
			Handler:    _LeadService_DeleteLead_Handler,
		},
		{
			MethodName: "GetListSection",
			Handler:    _LeadService_GetListSection_Handler,
		},
		{
			MethodName: "GetLeadReports",
			Handler:    _LeadService_GetLeadReports_Handler,
		},
		{
			MethodName: "GetActiveLeadCount",
			Handler:    _LeadService_GetActiveLeadCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lead.proto",
}

const (
	ExpectService_CreateExpect_FullMethodName = "/lead.ExpectService/CreateExpect"
	ExpectService_UpdateExpect_FullMethodName = "/lead.ExpectService/UpdateExpect"
	ExpectService_DeleteExpect_FullMethodName = "/lead.ExpectService/DeleteExpect"
)

// ExpectServiceClient is the client API for ExpectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// expect_service_start
type ExpectServiceClient interface {
	CreateExpect(ctx context.Context, in *CreateExpectRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	UpdateExpect(ctx context.Context, in *UpdateExpectRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	DeleteExpect(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error)
}

type expectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExpectServiceClient(cc grpc.ClientConnInterface) ExpectServiceClient {
	return &expectServiceClient{cc}
}

func (c *expectServiceClient) CreateExpect(ctx context.Context, in *CreateExpectRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, ExpectService_CreateExpect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expectServiceClient) UpdateExpect(ctx context.Context, in *UpdateExpectRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, ExpectService_UpdateExpect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expectServiceClient) DeleteExpect(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, ExpectService_DeleteExpect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExpectServiceServer is the server API for ExpectService service.
// All implementations must embed UnimplementedExpectServiceServer
// for forward compatibility.
//
// expect_service_start
type ExpectServiceServer interface {
	CreateExpect(context.Context, *CreateExpectRequest) (*AbsResponse, error)
	UpdateExpect(context.Context, *UpdateExpectRequest) (*AbsResponse, error)
	DeleteExpect(context.Context, *DeleteAbsRequest) (*AbsResponse, error)
	mustEmbedUnimplementedExpectServiceServer()
}

// UnimplementedExpectServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExpectServiceServer struct{}

func (UnimplementedExpectServiceServer) CreateExpect(context.Context, *CreateExpectRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExpect not implemented")
}
func (UnimplementedExpectServiceServer) UpdateExpect(context.Context, *UpdateExpectRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExpect not implemented")
}
func (UnimplementedExpectServiceServer) DeleteExpect(context.Context, *DeleteAbsRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExpect not implemented")
}
func (UnimplementedExpectServiceServer) mustEmbedUnimplementedExpectServiceServer() {}
func (UnimplementedExpectServiceServer) testEmbeddedByValue()                       {}

// UnsafeExpectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExpectServiceServer will
// result in compilation errors.
type UnsafeExpectServiceServer interface {
	mustEmbedUnimplementedExpectServiceServer()
}

func RegisterExpectServiceServer(s grpc.ServiceRegistrar, srv ExpectServiceServer) {
	// If the following call pancis, it indicates UnimplementedExpectServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExpectService_ServiceDesc, srv)
}

func _ExpectService_CreateExpect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExpectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).CreateExpect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_CreateExpect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).CreateExpect(ctx, req.(*CreateExpectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpectService_UpdateExpect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExpectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).UpdateExpect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_UpdateExpect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).UpdateExpect(ctx, req.(*UpdateExpectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpectService_DeleteExpect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAbsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).DeleteExpect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_DeleteExpect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).DeleteExpect(ctx, req.(*DeleteAbsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExpectService_ServiceDesc is the grpc.ServiceDesc for ExpectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExpectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lead.ExpectService",
	HandlerType: (*ExpectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateExpect",
			Handler:    _ExpectService_CreateExpect_Handler,
		},
		{
			MethodName: "UpdateExpect",
			Handler:    _ExpectService_UpdateExpect_Handler,
		},
		{
			MethodName: "DeleteExpect",
			Handler:    _ExpectService_DeleteExpect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lead.proto",
}

const (
	SetService_CreateSet_FullMethodName   = "/lead.SetService/CreateSet"
	SetService_UpdateSet_FullMethodName   = "/lead.SetService/UpdateSet"
	SetService_DeleteSet_FullMethodName   = "/lead.SetService/DeleteSet"
	SetService_ChangeToSet_FullMethodName = "/lead.SetService/ChangeToSet"
	SetService_GetById_FullMethodName     = "/lead.SetService/GetById"
)

// SetServiceClient is the client API for SetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// set_service_start
type SetServiceClient interface {
	CreateSet(ctx context.Context, in *CreateSetRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	UpdateSet(ctx context.Context, in *UpdateSetRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	DeleteSet(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	ChangeToSet(ctx context.Context, in *ChangeToSetRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	GetById(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*SetDataResponse, error)
}

type setServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSetServiceClient(cc grpc.ClientConnInterface) SetServiceClient {
	return &setServiceClient{cc}
}

func (c *setServiceClient) CreateSet(ctx context.Context, in *CreateSetRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, SetService_CreateSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) UpdateSet(ctx context.Context, in *UpdateSetRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, SetService_UpdateSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) DeleteSet(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, SetService_DeleteSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) ChangeToSet(ctx context.Context, in *ChangeToSetRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, SetService_ChangeToSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) GetById(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*SetDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDataResponse)
	err := c.cc.Invoke(ctx, SetService_GetById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SetServiceServer is the server API for SetService service.
// All implementations must embed UnimplementedSetServiceServer
// for forward compatibility.
//
// set_service_start
type SetServiceServer interface {
	CreateSet(context.Context, *CreateSetRequest) (*AbsResponse, error)
	UpdateSet(context.Context, *UpdateSetRequest) (*AbsResponse, error)
	DeleteSet(context.Context, *DeleteAbsRequest) (*AbsResponse, error)
	ChangeToSet(context.Context, *ChangeToSetRequest) (*AbsResponse, error)
	GetById(context.Context, *DeleteAbsRequest) (*SetDataResponse, error)
	mustEmbedUnimplementedSetServiceServer()
}

// UnimplementedSetServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSetServiceServer struct{}

func (UnimplementedSetServiceServer) CreateSet(context.Context, *CreateSetRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSet not implemented")
}
func (UnimplementedSetServiceServer) UpdateSet(context.Context, *UpdateSetRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSet not implemented")
}
func (UnimplementedSetServiceServer) DeleteSet(context.Context, *DeleteAbsRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSet not implemented")
}
func (UnimplementedSetServiceServer) ChangeToSet(context.Context, *ChangeToSetRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeToSet not implemented")
}
func (UnimplementedSetServiceServer) GetById(context.Context, *DeleteAbsRequest) (*SetDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedSetServiceServer) mustEmbedUnimplementedSetServiceServer() {}
func (UnimplementedSetServiceServer) testEmbeddedByValue()                    {}

// UnsafeSetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SetServiceServer will
// result in compilation errors.
type UnsafeSetServiceServer interface {
	mustEmbedUnimplementedSetServiceServer()
}

func RegisterSetServiceServer(s grpc.ServiceRegistrar, srv SetServiceServer) {
	// If the following call pancis, it indicates UnimplementedSetServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SetService_ServiceDesc, srv)
}

func _SetService_CreateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).CreateSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_CreateSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).CreateSet(ctx, req.(*CreateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_UpdateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).UpdateSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_UpdateSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).UpdateSet(ctx, req.(*UpdateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_DeleteSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAbsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).DeleteSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_DeleteSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).DeleteSet(ctx, req.(*DeleteAbsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_ChangeToSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeToSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).ChangeToSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_ChangeToSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).ChangeToSet(ctx, req.(*ChangeToSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAbsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_GetById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).GetById(ctx, req.(*DeleteAbsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SetService_ServiceDesc is the grpc.ServiceDesc for SetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lead.SetService",
	HandlerType: (*SetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSet",
			Handler:    _SetService_CreateSet_Handler,
		},
		{
			MethodName: "UpdateSet",
			Handler:    _SetService_UpdateSet_Handler,
		},
		{
			MethodName: "DeleteSet",
			Handler:    _SetService_DeleteSet_Handler,
		},
		{
			MethodName: "ChangeToSet",
			Handler:    _SetService_ChangeToSet_Handler,
		},
		{
			MethodName: "GetById",
			Handler:    _SetService_GetById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lead.proto",
}

const (
	LeadDataService_CreateLeadData_FullMethodName  = "/lead.LeadDataService/CreateLeadData"
	LeadDataService_UpdateLeadData_FullMethodName  = "/lead.LeadDataService/UpdateLeadData"
	LeadDataService_DeleteLeadData_FullMethodName  = "/lead.LeadDataService/DeleteLeadData"
	LeadDataService_ChangeLeadPlace_FullMethodName = "/lead.LeadDataService/ChangeLeadPlace"
)

// LeadDataServiceClient is the client API for LeadDataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// lead_service_start
type LeadDataServiceClient interface {
	CreateLeadData(ctx context.Context, in *CreateLeadDataRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	UpdateLeadData(ctx context.Context, in *UpdateLeadDataRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	DeleteLeadData(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error)
	ChangeLeadPlace(ctx context.Context, in *ChangeLeadPlaceRequest, opts ...grpc.CallOption) (*AbsResponse, error)
}

type leadDataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLeadDataServiceClient(cc grpc.ClientConnInterface) LeadDataServiceClient {
	return &leadDataServiceClient{cc}
}

func (c *leadDataServiceClient) CreateLeadData(ctx context.Context, in *CreateLeadDataRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadDataService_CreateLeadData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) UpdateLeadData(ctx context.Context, in *UpdateLeadDataRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadDataService_UpdateLeadData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) DeleteLeadData(ctx context.Context, in *DeleteAbsRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadDataService_DeleteLeadData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) ChangeLeadPlace(ctx context.Context, in *ChangeLeadPlaceRequest, opts ...grpc.CallOption) (*AbsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbsResponse)
	err := c.cc.Invoke(ctx, LeadDataService_ChangeLeadPlace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeadDataServiceServer is the server API for LeadDataService service.
// All implementations must embed UnimplementedLeadDataServiceServer
// for forward compatibility.
//
// lead_service_start
type LeadDataServiceServer interface {
	CreateLeadData(context.Context, *CreateLeadDataRequest) (*AbsResponse, error)
	UpdateLeadData(context.Context, *UpdateLeadDataRequest) (*AbsResponse, error)
	DeleteLeadData(context.Context, *DeleteAbsRequest) (*AbsResponse, error)
	ChangeLeadPlace(context.Context, *ChangeLeadPlaceRequest) (*AbsResponse, error)
	mustEmbedUnimplementedLeadDataServiceServer()
}

// UnimplementedLeadDataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLeadDataServiceServer struct{}

func (UnimplementedLeadDataServiceServer) CreateLeadData(context.Context, *CreateLeadDataRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLeadData not implemented")
}
func (UnimplementedLeadDataServiceServer) UpdateLeadData(context.Context, *UpdateLeadDataRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLeadData not implemented")
}
func (UnimplementedLeadDataServiceServer) DeleteLeadData(context.Context, *DeleteAbsRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLeadData not implemented")
}
func (UnimplementedLeadDataServiceServer) ChangeLeadPlace(context.Context, *ChangeLeadPlaceRequest) (*AbsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeLeadPlace not implemented")
}
func (UnimplementedLeadDataServiceServer) mustEmbedUnimplementedLeadDataServiceServer() {}
func (UnimplementedLeadDataServiceServer) testEmbeddedByValue()                         {}

// UnsafeLeadDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeadDataServiceServer will
// result in compilation errors.
type UnsafeLeadDataServiceServer interface {
	mustEmbedUnimplementedLeadDataServiceServer()
}

func RegisterLeadDataServiceServer(s grpc.ServiceRegistrar, srv LeadDataServiceServer) {
	// If the following call pancis, it indicates UnimplementedLeadDataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LeadDataService_ServiceDesc, srv)
}

func _LeadDataService_CreateLeadData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLeadDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).CreateLeadData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_CreateLeadData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).CreateLeadData(ctx, req.(*CreateLeadDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_UpdateLeadData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLeadDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).UpdateLeadData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_UpdateLeadData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).UpdateLeadData(ctx, req.(*UpdateLeadDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_DeleteLeadData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAbsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).DeleteLeadData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_DeleteLeadData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).DeleteLeadData(ctx, req.(*DeleteAbsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_ChangeLeadPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeLeadPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).ChangeLeadPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_ChangeLeadPlace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).ChangeLeadPlace(ctx, req.(*ChangeLeadPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeadDataService_ServiceDesc is the grpc.ServiceDesc for LeadDataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeadDataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lead.LeadDataService",
	HandlerType: (*LeadDataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLeadData",
			Handler:    _LeadDataService_CreateLeadData_Handler,
		},
		{
			MethodName: "UpdateLeadData",
			Handler:    _LeadDataService_UpdateLeadData_Handler,
		},
		{
			MethodName: "DeleteLeadData",
			Handler:    _LeadDataService_DeleteLeadData_Handler,
		},
		{
			MethodName: "ChangeLeadPlace",
			Handler:    _LeadDataService_ChangeLeadPlace_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lead.proto",
}
